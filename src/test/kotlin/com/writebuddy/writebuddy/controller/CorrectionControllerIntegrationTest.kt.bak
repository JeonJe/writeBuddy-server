package com.writebuddy.writebuddy.controller

import com.fasterxml.jackson.databind.ObjectMapper
import com.writebuddy.writebuddy.config.TestConfiguration
import com.writebuddy.writebuddy.controller.dto.request.CorrectionRequest
import com.writebuddy.writebuddy.domain.Correction
import com.writebuddy.writebuddy.domain.FeedbackType
import com.writebuddy.writebuddy.repository.CorrectionRepository
import org.junit.jupiter.api.AfterEach
import org.junit.jupiter.api.DisplayName
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureWebMvc
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.context.annotation.Import
import org.springframework.http.MediaType
import org.springframework.test.web.servlet.MockMvc
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*
import org.springframework.test.web.servlet.result.MockMvcResultMatchers.*
import org.springframework.transaction.annotation.Transactional
import org.springframework.test.context.TestPropertySource
import org.hamcrest.Matchers.containsString

@SpringBootTest
@AutoConfigureWebMvc
@Import(TestConfiguration::class)
@Transactional
@DisplayName("CorrectionController 통합 테스트")
class CorrectionControllerIntegrationTest {

    @Autowired
    private lateinit var mockMvc: MockMvc

    @Autowired
    private lateinit var objectMapper: ObjectMapper

    @Autowired
    private lateinit var correctionRepository: CorrectionRepository

    @AfterEach
    fun cleanup() {
        correctionRepository.deleteAll()
    }

    @Nested
    @DisplayName("POST /corrections")
    inner class CreateCorrectionTests {

        @Test
        @DisplayName("유효한 요청으로 교정을 생성하고 저장한다")
        fun createCorrection_validRequest() {
            val request = CorrectionRequest("hello world")
            val requestJson = objectMapper.writeValueAsString(request)

            mockMvc.perform(
                post("/corrections")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(requestJson)
            )
                .andExpect(status().isOk)
                .andExpect(jsonPath("$.id").exists())
                .andExpect(jsonPath("$.originSentence").value("hello world"))
                .andExpect(jsonPath("$.correctedSentence").exists())
                .andExpect(jsonPath("$.feedback").exists())
                .andExpect(jsonPath("$.feedbackType").exists())
                .andExpect(jsonPath("$.createdAt").exists())
        }

        @Test
        @DisplayName("빈 문장으로 요청하면 400 에러를 반환한다")
        fun createCorrection_emptyString() {
            val request = CorrectionRequest("")
            val requestJson = objectMapper.writeValueAsString(request)

            mockMvc.perform(
                post("/corrections")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(requestJson)
            )
                .andExpect(status().isBadRequest)
                .andExpect(jsonPath("$.error").value("Validation Failed"))
                .andExpect(jsonPath("$.message").exists())
        }

        @Test
        @DisplayName("1000자를 초과하는 문장으로 요청하면 400 에러를 반환한다")
        fun createCorrection_tooLongSentence() {
            val longSentence = "a".repeat(1001)
            val request = CorrectionRequest(longSentence)
            val requestJson = objectMapper.writeValueAsString(request)

            mockMvc.perform(
                post("/corrections")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(requestJson)
            )
                .andExpect(status().isBadRequest)
                .andExpect(jsonPath("$.error").value("Validation Failed"))
                .andExpect(jsonPath("$.message").value(containsString("1000자 이하")))
        }

        @Test
        @DisplayName("허용되지 않은 문자가 포함된 문장으로 요청하면 400 에러를 반환한다")
        fun createCorrection_invalidCharacters() {
            val invalidRequest = CorrectionRequest("hello 한글 world")
            val requestJson = objectMapper.writeValueAsString(invalidRequest)

            mockMvc.perform(
                post("/corrections")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(requestJson)
            )
                .andExpect(status().isBadRequest)
                .andExpect(jsonPath("$.error").value("Validation Failed"))
                .andExpect(jsonPath("$.message").value(containsString("영문자, 숫자, 기본 구두점만 허용")))
        }

        @Test
        @DisplayName("Content-Type이 잘못된 경우 400 에러를 반환한다")
        fun createCorrection_invalidContentType() {
            val request = CorrectionRequest("hello world")
            val requestJson = objectMapper.writeValueAsString(request)

            mockMvc.perform(
                post("/corrections")
                    .contentType(MediaType.TEXT_PLAIN)
                    .content(requestJson)
            )
                .andExpect(status().isBadRequest)
        }
    }

    @Nested
    @DisplayName("GET /corrections")
    inner class GetAllCorrectionsTests {

        @Test
        @DisplayName("저장된 모든 교정 결과를 조회한다")
        fun getAllCorrections_returnsAllSavedCorrections() {
            // 테스트 데이터 준비
            val correction1 = Correction(
                originSentence = "hello world",
                correctedSentence = "Hello, world!",
                feedback = "대문자로 시작해야 합니다.",
                feedbackType = FeedbackType.GRAMMAR
            )
            val correction2 = Correction(
                originSentence = "i am student",
                correctedSentence = "I am a student.",
                feedback = "대문자와 관사를 추가해야 합니다.",
                feedbackType = FeedbackType.STYLE
            )
            
            correctionRepository.saveAll(listOf(correction1, correction2))

            mockMvc.perform(get("/corrections"))
                .andExpect(status().isOk)
                .andExpect(jsonPath("$").isArray)
                .andExpect(jsonPath("$.length()").value(2))
                .andExpect(jsonPath("$[0].originSentence").exists())
                .andExpect(jsonPath("$[1].originSentence").exists())
        }

        @Test
        @DisplayName("교정 결과가 없으면 빈 배열을 반환한다")
        fun getAllCorrections_emptyResult() {
            mockMvc.perform(get("/corrections"))
                .andExpect(status().isOk)
                .andExpect(jsonPath("$").isArray)
                .andExpect(jsonPath("$.length()").value(0))
        }
    }

    @Nested
    @DisplayName("GET /corrections/statistics")
    inner class GetStatisticsTests {

        @Test
        @DisplayName("피드백 타입별 통계를 조회한다")
        fun getStatistics_returnsFeedbackTypeCount() {
            // 테스트 데이터 준비
            val corrections = listOf(
                Correction(
                    originSentence = "test1",
                    correctedSentence = "Test1",
                    feedback = "grammar feedback",
                    feedbackType = FeedbackType.GRAMMAR
                ),
                Correction(
                    originSentence = "test2",
                    correctedSentence = "Test2",
                    feedback = "grammar feedback 2",
                    feedbackType = FeedbackType.GRAMMAR
                ),
                Correction(
                    originSentence = "test3",
                    correctedSentence = "Test3",
                    feedback = "style feedback",
                    feedbackType = FeedbackType.STYLE
                )
            )
            
            correctionRepository.saveAll(corrections)

            mockMvc.perform(get("/corrections/statistics"))
                .andExpect(status().isOk)
                .andExpect(jsonPath("$.GRAMMAR").value(2))
                .andExpect(jsonPath("$.STYLE").value(1))
        }

        @Test
        @DisplayName("통계 데이터가 없으면 빈 통계를 반환한다")
        fun getStatistics_emptyStatistics() {
            mockMvc.perform(get("/corrections/statistics"))
                .andExpect(status().isOk)
        }
    }

    @Nested
    @DisplayName("에러 처리 테스트")
    inner class ErrorHandlingTests {

        @Test
        @DisplayName("JSON 형식이 잘못된 경우 400 에러를 반환한다")
        fun handleMalformedJson() {
            val malformedJson = """{"originSentence": "test", "extra": }"""

            mockMvc.perform(
                post("/corrections")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(malformedJson)
            )
                .andExpect(status().isBadRequest)
        }

        @Test
        @DisplayName("필수 필드가 누락된 경우 400 에러를 반환한다")
        fun handleMissingRequiredField() {
            val incompleteJson = """{}"""

            mockMvc.perform(
                post("/corrections")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(incompleteJson)
            )
                .andExpect(status().isBadRequest)
                .andExpect(jsonPath("$.error").value("Validation Failed"))
        }
    }
}